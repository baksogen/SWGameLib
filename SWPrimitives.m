////  SWPrimitives.m//  SWGameLib//////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 9/15/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWPrimitives.h"#import "CGPointExtension.h"#define ANTIALIAS_WIDTH 1.0fvoid swDrawLineCC(CGPoint head, CGPoint tail, CGFloat width, ccColor4B colorH, ccColor4B colorT) {    CGFloat e, ew;    CGPoint t, b, tl, bl, d;    CGPoint seT, seB, seTL, seBL;    ccColor4B etC, tc, ehC, hc;        hc   = colorH;    tc   = colorT;    ehC  = colorH;    etC  = colorT;        ehC.a =  etC.a = 0;        e    = width*0.5f;    ew   = e + ANTIALIAS_WIDTH;    d    = ccpNormalize(ccpSub(head, tail));    t    = ccpMult(ccpPerp(d), e);    b    = ccpMult(ccpRPerp(d), e);    seT  = ccpMult(ccpNormalize(t), ew);    seB  = ccpMult(ccpNormalize(b), ew);    tl   = ccpMult(ccpNormalize(ccpAdd(t, ccpMult(d, e))), e);    bl   = ccpMult(ccpNormalize(ccpAdd(b, ccpMult(d, e))), e);    seTL = ccpMult(ccpNormalize(tl), ew);    seBL = ccpMult(ccpNormalize(bl), ew);        CGPoint hV[11] = {        seB, b, seBL, bl, seTL, tl, seT, t, b, tl, bl    };    CGPoint bV[11];    for (int i = 0; i < 11; i++) {        bV[i] = ccpRotateByAngle(hV[i], CGPointZero, M_PI);    }    for (int i = 0; i < 11; i++) {        hV[i] = ccpAdd(hV[i], head);        bV[i] = ccpAdd(bV[i], tail);    }    CGPoint lV[8] = {        hV[6], bV[0], hV[7], bV[1], hV[1], bV[7], hV[0], bV[6]      };        ccColor4B ehColors[11] = {        ehC, hc, ehC, hc, ehC, hc, ehC, hc, hc, hc, hc    };        ccColor4B etColors[11] = {        etC, tc, etC, tc, etC, tc, etC, tc, tc, tc, tc    };        ccColor4B colors[8] = {        ehC, etC, hc, tc, hc, tc, ehC, etC    };        //draw head    glColorPointer(4, GL_UNSIGNED_BYTE, 0, ehColors);	glVertexPointer(2, GL_FLOAT, 0, hV);	    	glDrawArrays(GL_TRIANGLE_STRIP, 0, 11);        //draw tail    glColorPointer(4, GL_UNSIGNED_BYTE, 0, etColors);	glVertexPointer(2, GL_FLOAT, 0, bV);		glDrawArrays(GL_TRIANGLE_STRIP, 0, 11);        //draw body    glColorPointer(4, GL_UNSIGNED_BYTE, 0, colors);	glVertexPointer(2, GL_FLOAT, 0, lV);	    	glDrawArrays(GL_TRIANGLE_STRIP, 0, 8);}void swDrawLineC(CGPoint head, CGPoint tail, CGFloat width, ccColor4B color) {    glDisable(GL_TEXTURE_2D);	glDisableClientState(GL_TEXTURE_COORD_ARRAY);	    swDrawLineCC(head, tail, width, color, color);    	glEnableClientState(GL_TEXTURE_COORD_ARRAY);	glEnable(GL_TEXTURE_2D);	}void swDrawPoly( CGPoint *poli, CGFloat width, NSUInteger numberOfPoints, ccColor4B color){       glDisable(GL_TEXTURE_2D);	glDisableClientState(GL_TEXTURE_COORD_ARRAY);	int j;    	for (int i = 0; i < numberOfPoints; i++) {                if (i+1 >= numberOfPoints) {            j = 0;        } else {            j = i+1;        }        swDrawLineCC(poli[i], poli[j], width, color, color);    }    	glEnableClientState(GL_TEXTURE_COORD_ARRAY);	glEnable(GL_TEXTURE_2D);	}void swDrawCircle(CGPoint pos, CGFloat radius, CGFloat width, NSUInteger numberOfPoints, ccColor4B color) {        const int       arrayLength = 2*numberOfPoints+2;    const ccColor4B eColor      = ccc4(color.r, color.g, color.b, 0);        CGPoint   centeri[numberOfPoints], centero[numberOfPoints], outer[numberOfPoints], inner[numberOfPoints];    CGPoint   pArray[arrayLength];    ccColor4B cArray[arrayLength];    CGFloat   r, s;    CGAffineTransform tt, ts;        r         = 2*M_PI/numberOfPoints;    centeri[0] = ccp(0,radius);        for (int i = 1; i < numberOfPoints; i++) {        centeri[i] = ccpRotateByAngle(centeri[i-1], CGPointZero, r);    }        // setup centero    s  = (radius+width*0.5f)/radius;    ts = CGAffineTransformMakeScale(s, s);    tt = CGAffineTransformMakeTranslation(pos.x, pos.y);    for (int i = 0; i < numberOfPoints; i++) {        centero[i] = CGPointApplyAffineTransform(CGPointApplyAffineTransform(centeri[i], ts), tt);    }        // setup outer    s = (radius+width*0.5f+ANTIALIAS_WIDTH)/radius;    ts = CGAffineTransformMakeScale(s, s);    for (int i = 0; i < numberOfPoints; i++) {        outer[i] = CGPointApplyAffineTransform(CGPointApplyAffineTransform(centeri[i], ts), tt);    }        // setup inner    s = (radius-width*0.5f-ANTIALIAS_WIDTH)/radius;    ts = CGAffineTransformMakeScale(s, s);    for (int i = 0; i < numberOfPoints; i++) {        inner[i] = CGPointApplyAffineTransform(CGPointApplyAffineTransform(centeri[i], ts), tt);    }        // setup centeri    s = (radius-width*0.5f)/radius;    ts = CGAffineTransformMakeScale(s, s);    for (int i = 0; i < numberOfPoints; i++) {        centeri[i] = CGPointApplyAffineTransform(CGPointApplyAffineTransform(centeri[i], ts), tt);    }        glDisable(GL_TEXTURE_2D);	glDisableClientState(GL_TEXTURE_COORD_ARRAY);        // centero - centeri    for (int i = 0; i < arrayLength; i++) {        if (i == arrayLength-2) {            pArray[i] = centero[0];        } else if (i == arrayLength-1) {            pArray[i] = centeri[0];        } else {            if (i%2 == 0) {                pArray[i] = centero[i/2];            } else {                pArray[i] = centeri[i/2];            }        }        cArray[i] = color;    }    glColorPointer(4, GL_UNSIGNED_BYTE, 0, cArray);	glVertexPointer(2, GL_FLOAT, 0, pArray);		glDrawArrays(GL_TRIANGLE_STRIP, 0, arrayLength);            // outer - centero    for (int i = 0; i < arrayLength; i++) {        if (i == arrayLength-2) {            pArray[i] = outer[0];            cArray[i] = eColor;        } else if (i == arrayLength-1) {            pArray[i] = centero[0];            cArray[i] = color;        } else {            if (i%2 == 0) {                pArray[i] = outer[i/2];                cArray[i] = eColor;            } else {                pArray[i] = centero[i/2];                cArray[i] = color;            }        }            }    glColorPointer(4, GL_UNSIGNED_BYTE, 0, cArray);	glVertexPointer(2, GL_FLOAT, 0, pArray);		glDrawArrays(GL_TRIANGLE_STRIP, 0, arrayLength);        // centeri - inner    for (int i = 0; i < arrayLength; i++) {        if (i == arrayLength-2) {            pArray[i] = centeri[0];            cArray[i] = color;        } else if (i == arrayLength-1) {            pArray[i] = inner[0];            cArray[i] = eColor;        } else {            if (i%2 == 0) {                pArray[i] = centeri[i/2];                cArray[i] = color;            } else {                pArray[i] = inner[i/2];                cArray[i] = eColor;            }        }            }    glColorPointer(4, GL_UNSIGNED_BYTE, 0, cArray);	glVertexPointer(2, GL_FLOAT, 0, pArray);		glDrawArrays(GL_TRIANGLE_STRIP, 0, arrayLength);        glEnableClientState(GL_TEXTURE_COORD_ARRAY);	glEnable(GL_TEXTURE_2D);}