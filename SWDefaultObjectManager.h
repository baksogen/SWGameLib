////  SWDefaultSpawnManager.h//  SWGameLib//////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 4/13/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import <Foundation/Foundation.h>#import "chipmunk.h"#import "SWEvent.h"#define LIGHT_DISTANCE    200000.0f#define PE_UPDATE_TIME    0.04@class SWPhysicsObject, SWDefaultObjectManager, SWEvent, SWObjectTemplates;/** * Delegate to respond to a point query result. */@protocol SWPointQueryDelegate/** * This method is called when a point query found an object. * * @param manager the object manager that issued the query. * @param obj the object found. * @param point the location that is used for the query. */-(void)objectManager:(SWDefaultObjectManager *)manager foundObject:(SWPhysicsObject *)obj atPoint:(NSValue *)point;@end/** * Spawn and despawn SWPhysicsObject objects. This class makes chipmunk transparent * to the main game logic, except collision handling. * It waits until next time step to perform spawning or despawning. * so that, they can be done avoiding chipmunk spack locks. * * chipmunk update iteration is done in a separate background thread. * event detection/trigger is done in a separate background thread. */@interface SWDefaultObjectManager :          NSObject <           SWEventCheckerDelegate,           SWEventHandlerDelegate> {@protected    NSMutableArray        *_spawnedObjects;    SWObjectTemplates     *_templates;    cpSpace               *_cmSpace;    NSOperationQueue      *_opPEQueue;    NSOperationQueue      *_opEUQueue;    NSInvocationOperation *_updateOp;    NSInvocationOperation *_eventOp;@private    CGPoint               _lightSource;    NSTimeInterval        _lastPEUpdate;    NSUInteger            _tagCounter;    NSMutableArray        *_spawningObjects;    NSMutableArray        *_despawningObjects;    NSMutableArray        *_events;}/** * Light source location. This is used for dynamic shadow offsetting. * only x, y coordinates are defined here. * Use LIGHT_DISTANCE variable to change the height of light source.(z-coordinate) */@property (nonatomic, assign)           CGPoint           lightSource;/** * The physics engine operation queue that runs chipmunk's update method. */@property (nonatomic, retain, readonly) NSOperationQueue  *opPEQueue;/** * Event queue */@property (nonatomic, retain, readonly) NSOperationQueue  *opEUQueue;/** * Object template manager */@property (nonatomic, retain)           SWObjectTemplates *templates;/** * Returns auto-released manager object * * @return manager object */+(id)manager;/** * Make the given object available to chipmunk space. */-(void)spawnEntity:(SWPhysicsObject *)entity;/** * Removes the object from chipmunk. All chipmunk objects are destroyed. * DO NOT re-insert by calling spawnEntity: selector. */-(void)despawnEntity:(SWPhysicsObject *)entity;/** * Returns chipmunk space object. Use this selector if you need to customize * space. * * @return chipmunk space object. */-(cpSpace *)physicalSpace;/** * Determines if a given object is currently trying to spawn, but it isn't yet. * * @return If YES, it is waiting until the next time step to spawn. */-(BOOL)isSpawningEntity:(SWPhysicsObject *)entity;/** * Determines if a given object is currently trying to despawn, but it isn't yet. * * @return If YES, it is waiting until the next time step to despawn. */-(BOOL)isDespawningEntity:(SWPhysicsObject *)entity;/** * Returns an array that contains spawned objects, which may contain despawning * objects. *  * @return an array with spawned objects. */-(NSArray *)spawnedEntities;/** * Unschedules chipmunk 'step' timer. You must call this before exiting from * the main game logic that used this manager. Otherwise, the game will * continue running in the background. */-(void)pause:(id)sender;/** * Resumes chipmunk 'step' timer. */-(void)resume:(id)sender;/** * Returns the tag that uniquely identifies a given object. *  * @param object to search tag. * @return the tag of the given object. */-(NSUInteger)objectIDOfEntity:(SWPhysicsObject *)entity;/** * Returns an object with a given tag. * @param tag to search object. * @return The object found. */-(SWPhysicsObject *)entityWithObjectID:(NSUInteger)idx;/** * It queries the physics engine to find an entity at a given position, layers. * It calls the delegate's objectManager:foundObject: method when it's finished. * * @param pos position to query. * @param layers chipmunk to layers to filter * @param delegate delegate to respond to the result */-(void)entityAtPosition:(CGPoint)pos inLayers:(cpLayers)layers withDelegate:(id <SWPointQueryDelegate>)delegate;/** * Resets both visual and physical spaces */-(void)onExit;/** * Starting chipmunk engine. it also schedules a timer for object updates */-(void)onEnter;/** * Registers collisions that have no impact on anything. * * @param t1 type * @param t2 type */-(void)registerNegligibleCollisionWithType:(cpCollisionType)t1 type:(cpCollisionType)t2;/** * Registers collisions that do only physics simulation and do not change any object properties. * @param t1 type * @param t2 type */-(void)registerSimpleCollisionWithType:(cpCollisionType)t1 type:(cpCollisionType)t2;/** * Registers collisions that do both simulation and change object properties. * @param t1 type * @param t2 type */-(void)registerObjectCollisionWithType:(cpCollisionType)t1 type:(cpCollisionType)t2;/** * Adds a new event * * @param e event */-(void)addEvent:(SWEvent *)event;/** * Removes an event * * @param e event */-(void)removeEvent:(SWEvent *)event;/** * Override to generate custom event objects. * * @param eventID id to identify event type * @return SWEvent object */-(SWEvent *)eventWithID:(NSUInteger)eventID;@end