////  SWSteerObject.m//  SWGameLib//////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 9/17/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWSteerObject.h"#import "NSMutableArray+Sorting.h"#import "SWDefaultObjectManager.h"#import "SWGameLib.h"#import "CGPointExtension.h"#import "ccMacros.h"#define SEPARATION_WEIGHT 0.5f#define WANDER_WEIGHT     0.5f#define WANDER_RADIUS     200.0f#define WANDER_RATE       0.05f@interface SWSteerObject()@property (nonatomic, retain) SWPhysicsObject *_targetObj;-(NSComparisonResult)_compareAngleBounds:(const CGFloat)f;-(const CGFloat)_pursuitTimeFactorWithParallelness:(const CGFloat)pv forwardness:(const CGFloat)fv;@end@implementation SWSteerObject@synthesize _targetObj;@synthesize target      = _target;@synthesize states      = _states;-(id)initWithTemplate:(NSDictionary *)info {    if ((self = [super initWithTemplate:info])) {        _nearByObjects = [NSMutableArray new];        _obstacles     = [NSMutableArray new];        _states        = SteerInactive;        _targetObj     = nil;        _autorotation  = NO;        _wv            = CGPointZero;        _p             = _f = 0.0f;        _steerRate     = 1.0f;    }    return self;}-(void)dealloc {    [_targetObj     release];    [_steerSensor   release];    [_nearByObjects release];    [super dealloc];}-(void)despawnOnCurrentThread {    if (self.spawnManager) {        [_steerSensor despawn];        [_obstacleSensor despawn];    }    [super despawnOnCurrentThread];}#pragma mark -#pragma mark States (Start)-(void)arrival:(CGPoint)p {    _target = p;        _states |= SteerArrival;}-(void)seek:(CGPoint)p {    _target = p;    _states |= SteerSeek;}-(void)pursuit:(SWPhysicsObject *)obj {    self._targetObj = obj;    _states |= SteerPursuit;}-(void)flee:(CGPoint)p {    _target = p;    _states |= SteerFlee;}-(void)evade:(SWPhysicsObject *)obj {    self._targetObj = obj;    _states |= SteerEvasion;}-(void)avoidObtaclesInLayers:(cpLayers)layers type:(cpCollisionType)type {    _obstacleSensor = [[SWBoxSensor alloc] initWithWidth:self.sprite.contentSize.width*2 height:self.sprite.contentSize.height];    _obstacleSensor.spawnManager  = self.spawnManager;    _obstacleSensor.parent        = self;    _obstacleSensor.playerIdx     = self.playerIdx;    _obstacleSensor.shape->group  = self.shape->group;    _obstacleSensor.shape->layers = layers;    _obstacleSensor.shape->collision_type = type;        [_obstacleSensor spawn];        _states |= SteerAvoidance;}-(void)separateFromObjectsWithLayers:(cpLayers)layers type:(cpCollisionType)type {    _steerSensor   = [[SWCircleSensor alloc] initWithRadius:1.2f*MAX(self.sprite.contentSize.width, self.sprite.contentSize.height)];    _steerSensor.spawnManager  = self.spawnManager;    _steerSensor.parent        = self;    _steerSensor.playerIdx     = self.playerIdx;    _steerSensor.shape->group  = self.shape->group;    _steerSensor.shape->layers = layers;    _steerSensor.shape->collision_type = type;        [_steerSensor spawn];        _states |= SteerSeparation;}-(void)wander:(CGPoint)pos {    _states |= SteerWander;    _wv     = ccpNormalize(ccpPerp(pos));}-(void)start {    _states &= (SteerAllStates - SteerInactive);}#pragma mark -#pragma mark States (Stop)-(void)stopArrival {    _states &= (SteerAllStates - SteerArrival);}-(void)stopSeek {    _states &= (SteerAllStates - SteerSeek);}-(void)stopPursuit {    self._targetObj = nil;    _states &= (SteerAllStates - SteerPursuit);}-(void)stopFlee {    _states &= (SteerAllStates - SteerFlee);}-(void)stopEvade {    self._targetObj = nil;}-(void)stopAvoidance {    [_obstacleSensor despawn];    [_obstacleSensor release];    _obstacleSensor = nil;    _states &= (SteerAllStates - SteerAvoidance);}-(void)stopSeparation {    [_steerSensor despawn];    [_steerSensor release];    _steerSensor = nil;    _states &= (SteerAllStates - SteerSeparation); }-(void)stopWander {    _wv     = CGPointZero;    _states &= (SteerAllStates - SteerWander);}-(void)stop {    _states |= SteerInactive;}#pragma mark -#pragma mark Sensors-(void)sensor:(id)sensor foundObject:(SWPhysicsObject *)obj {    if (sensor == _steerSensor) {        if (![_nearByObjects objectWithObjectID:obj.objectID]) {            [_nearByObjects insertSortedObject:obj];        }       } else {        if (![_obstacles objectWithObjectID:obj.objectID]) {            [_obstacles insertSortedObject:obj];        }    }}-(void)sensor:(id)sensor lostObject:(SWPhysicsObject *)obj {    if (sensor == _steerSensor) {        if ([_nearByObjects objectWithObjectID:obj.objectID]) {            [_nearByObjects removeSortedObject:obj];        }       } else {        if ([_obstacles objectWithObjectID:obj.objectID]) {            [_obstacles removeSortedObject:obj];        }    }}#pragma mark -#pragma mark Update// XXX: taken from open steer library.-(NSComparisonResult)_compareAngleBounds:(const CGFloat)f {    const float max = 0.707f;    const float min = -0.707f;    if (max < f) {        return NSOrderedDescending;    } else if (min > f) {        return NSOrderedAscending;    }    return NSOrderedSame;}-(const CGFloat)_pursuitTimeFactorWithParallelness:(const CGFloat)pv forwardness:(const CGFloat)fv {    const NSComparisonResult p = [self _compareAngleBounds:pv];    const NSComparisonResult f = [self _compareAngleBounds:fv];        CGFloat timeFactor;        switch (f) {        case NSOrderedDescending:            switch (p) {                case NSOrderedDescending:          // ahead, parallel                    timeFactor = 4;                    break;                case NSOrderedSame:           // ahead, perpendicular                    timeFactor = 1.8f;                    break;                case NSOrderedAscending:          // ahead, anti-parallel                    timeFactor = 0.85f;                    break;            }            break;        case NSOrderedSame:            switch (p) {                case NSOrderedDescending:          // aside, parallel                    timeFactor = 1;                    break;                case NSOrderedSame:           // aside, perpendicular                    timeFactor = 0.8f;                    break;                case NSOrderedAscending:          // aside, anti-parallel                    timeFactor = 4;                    break;            }            break;        case NSOrderedAscending:            switch (p) {                case NSOrderedDescending:          // behind, parallel                    timeFactor = 0.5f;                    break;                case NSOrderedSame:           // behind, perpendicular                    timeFactor = 2;                    break;                case NSOrderedAscending:          // behind, anti-parallel                    timeFactor = 2;                    break;            }            break;    }    return (const CGFloat)timeFactor;}-(void)update {    [super update];    if (self.spawnManager) {                if (_steerSensor) {            _steerSensor.position    = self.position;        }                if (_obstacleSensor) {            _obstacleSensor.rotation = self.rotation;            _obstacleSensor.position = ccpAdd(ccpRotateByAngle(ccp(self.sprite.contentSize.width*2.5, 0.0f), CGPointZero, self.rotation), self.position);        }                if (!(_states & SteerInactive)) {            CGPoint v;            CGPoint final;            CGFloat maxSpeed;                        final    = CGPointZero;            maxSpeed = [[self dataValueForKey:kSteerMaxSpeed] floatValue];                        if ((_states & SteerPursuit)||(_states & SteerEvasion)) {                if (_targetObj && _targetObj.spawnManager) {                    CGPoint predictor;                    if (!CGPointEqualToPoint(_targetObj.linearVelocity, CGPointZero)) {                        CGFloat t;                        CGPoint offset;                        offset    = ccpSub(_targetObj.position, self.position);                        _p        = ccpDot(ccpNormalize(self.linearVelocity), ccpNormalize(_targetObj.linearVelocity));                        _f        = ccpDot(ccpNormalize(self.linearVelocity), ccpNormalize(offset));                        t         = [self _pursuitTimeFactorWithParallelness:_p forwardness:_f];                        v         = ccpMult(_targetObj.linearVelocity, t*ccpLength(offset)/maxSpeed);                        predictor = ccpAdd(v, _targetObj.position);                    } else {                        predictor = _targetObj.position;                    }                    v     = ccpMult(ccpNormalize(ccpSub(predictor, self.position)), maxSpeed);                    if ((_states & SteerEvasion)) {                        v = ccpRotateByAngle(v, CGPointZero, M_PI);                    }                    final = ccpSub(v, self.linearVelocity);                    final = ccpMult(ccpNormalize(final), maxSpeed);                } else {                    self._targetObj = nil;                    final = self.linearVelocity;                }            } else if ((_states & SteerSeek) || (_states & SteerFlee)) {                v     = ccpMult(ccpNormalize(ccpSub(_target, self.position)), maxSpeed);                                if ((_states & SteerFlee)) {                    v = ccpRotateByAngle(v, CGPointZero, M_PI);                }                                final = ccpSub(v, self.linearVelocity);            } else if ((_states & SteerArrival)) {                CGFloat d;                CGFloat rv, cv;                d     = ccpDistance(_target, self.position);                rv    = maxSpeed * (d/SLOWING_DISTANCE);                cv    = MIN(rv, maxSpeed);                v     = ccpMult(ccpNormalize(ccpSub(_target, self.position)), cv);                final = ccpSub(v, self.linearVelocity);            }                        if ((_states & SteerAvoidance) && [_obstacles count] > 0) {                SWPhysicsObject *nearest;                CGFloat         d, nd;                                nearest  = nil;                d        = CGFLOAT_MAX;                for (SWPhysicsObject *obj in _obstacles) {                    nd = ccpDistance(self.position, obj.position);                    if (nd < d) {                        nearest = obj;                        d       = nd;                    }                }                v = ccpSub(nearest.position, self.position);                if (ccpToAngle(v) == ccpToAngle(self.linearVelocity)) {                    v     = ccpPerp(self.linearVelocity);                } else {                    d  = ccpLength(self.linearVelocity);                    v  = ccpMult(ccpNormalize(v), d);                    v  = ccpSub(self.linearVelocity, v);                    nd = MAX(nearest.sprite.contentSize.width, nearest.sprite.contentSize.height);                    nd = fabsf(nd - d);                    v  = ccpMult(ccpNormalize(v), nd);                }                final = ccpAdd(final, v);            }                        if ((_states & SteerSeparation) && [_nearByObjects count] > 0) {                v = CGPointZero;                                for (SWPhysicsObject *obj in _nearByObjects) {                    v = ccpAdd(v,ccpSub(self.position, obj.position));                }                v     = ccpMult(v, 1/[_nearByObjects count]);                final = ccpAdd(ccpMult(final, 1.0f-SEPARATION_WEIGHT), ccpMult(v, SEPARATION_WEIGHT));            }                        if ((_states & SteerWander) && !CGPointEqualToPoint(final, CGPointZero)) {                if (ccpLength(_wv) > WANDER_RADIUS) {                    _wv = ccpRotateByAngle(_wv, CGPointZero, M_PI);                    _wv = ccpNormalize(_wv);                }                                _wv   = ccpMult(ccpNormalize(_wv), ccpLength(_wv)+WANDER_RADIUS*WANDER_RATE);                final = ccpAdd(ccpMult(final, 1.0f-WANDER_WEIGHT), ccpMult(_wv, WANDER_WEIGHT));            }                        if (_steerRate < 1.0f && CGPointEqualToPoint(_wv, CGPointZero)) {                final = ccpAdd(ccpMult(final, 1.0f-_steerRate), ccpMult(self.linearVelocity, _steerRate));                final = ccpMult(ccpNormalize(final), maxSpeed);            }                        [self resetForce];            [self applyForce:ccpMult(final, [[self dataValueForKey:kSWOMass] floatValue])];                        if (CGPointEqualToPoint(final, CGPointZero)) {                self.linearVelocity = final;            }        }                if (!CGPointEqualToPoint(self.linearVelocity, CGPointZero) && _autorotation &&            self.angularVelocity == 0.0f) {            self.rotation = ccpToAngle(self.linearVelocity);        }            }}@end