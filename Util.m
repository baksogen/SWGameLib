////  Util.m//  SWGameLib////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 3/16/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "Util.h"#import "CCSpriteFrameCache.h"#import "CCGrid.h"#import "SWDebug.h"@implementation Util+(CCAnimation *)animationWithName:(NSString *)name                           action:(NSString *)action                       frameCount:(NSUInteger)count                            delay:(CGFloat)time {    NSMutableArray    *frames;    CCSpriteFrame     *frame;    CCAnimation       *animation;        frames = [NSMutableArray array];    for (int i=1; i<=count; i++) {        frame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:                        [NSString stringWithFormat:@"%@_%@_%02d.png",name,action,i]];        [frames addObject:frame];    }        animation = [CCAnimation animationWithName:[NSString stringWithFormat:@"%@_%@",name,action]                                         delay:time                                        frames:frames];                      return animation;}+(CCAnimation *)reversedAnimationWithName:(NSString *)name                                   action:(NSString *)action                               frameCount:(NSUInteger)count                                    delay:(CGFloat)time {    NSMutableArray    *frames;    CCSpriteFrame     *frame;    CCAnimation       *animation;        frames = [NSMutableArray array];    for (int i=count; i>=1; i--) {        frame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:                 [NSString stringWithFormat:@"%@_%@_%02d.png",name,action,i]];        [frames addObject:frame];    }        animation = [CCAnimation animationWithName:[NSString stringWithFormat:@"%@_%@",name,action]                                         delay:time                                        frames:frames];        return animation;}+(void)loadGameData {    NSMutableDictionary *gameData;    NSString            *path;    NSArray             *paths;    NSAutoreleasePool   *pool;        pool  = [NSAutoreleasePool new];    paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    path  = [[paths objectAtIndex:0] stringByAppendingPathComponent:@"GameData.plist"];    if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {        gameData = [NSDictionary dictionaryWithContentsOfFile:                                [[NSBundle mainBundle] pathForResource:@"GameData"                                                                 ofType:@"plist"]];        gameData = [[gameData mutableCopy] autorelease];        [[UIApplication sharedApplication].delegate performSelector:@selector(setGameData:)                                                          withObject:gameData];        [self saveGameData];    } else {        gameData = [NSDictionary dictionaryWithContentsOfFile:path];        gameData = [[gameData mutableCopy] autorelease];        [[UIApplication sharedApplication].delegate performSelector:@selector(setGameData:)                                                         withObject:gameData];    }    [pool drain];}+(void)saveGameData {    NSMutableDictionary *gameData;    NSString            *path;    NSArray             *paths;    NSAutoreleasePool   *pool;        pool  = [NSAutoreleasePool new];    paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    path  = [[paths objectAtIndex:0] stringByAppendingPathComponent:@"GameData.plist"];    gameData = [Util gameData];        [gameData writeToFile:path atomically:NO];    [pool drain];}+(NSDictionary *)levelDataWithName:(NSString *)name {    NSDictionary      *levelData;        levelData = [[NSDictionary dictionaryWithContentsOfFile:                     [[NSBundle mainBundle] pathForResource:name ofType:@"plist"]] retain];        SWAssert(levelData != nil, @"Level data is nil");                     return [levelData autorelease];}+(NSMutableDictionary *)gameData {    NSMutableDictionary *gameData;        gameData = [[[UIApplication sharedApplication].delegate performSelector:@selector(gameData)] retain];        return [gameData autorelease];}+(void)tiltY3DwithNode:(CCNode *)target angle:(CGFloat)angle {    /**     * This is from cocos2d source flipX3D grid action     */    CCGrid3D *grid = (CCGrid3D *)[target grid];	CGFloat mz = sinf( angle );	angle = angle / 2.0f;     // x calculates degrees from 0 to 90	CGFloat my = cosf( angle );		ccVertex3F	v0, v1, v, diff;		v0 = [grid originalVertex:ccg(1,1)];	v1 = [grid originalVertex:ccg(0,0)];		CGFloat	y0 = v0.y;	CGFloat	y1 = v1.y;	CGFloat y;	ccGridSize	a, b, c, d;		if ( y0 > y1 )	{		// Normal Grid		a = ccg(0,0);		b = ccg(0,1);		c = ccg(1,0);		d = ccg(1,1);		y = y0;	}	else	{		// Reversed Grid		b = ccg(0,0);		a = ccg(0,1);		d = ccg(1,0);		c = ccg(1,1);		y = y1;	}		diff.y = y - y * my;	diff.z = fabsf( floorf( (y * mz) / 4.0f ) );		// bottom-left	v = [grid originalVertex:a];	v.y = diff.y;	v.z += diff.z;	[grid setVertex:a vertex:v];		// upper-left	v = [grid originalVertex:b];	v.y -= diff.y;	v.z -= diff.z;	[grid setVertex:b vertex:v];		// bottom-right	v = [grid originalVertex:c];	v.y = diff.y;	v.z += diff.z;	[grid setVertex:c vertex:v];		// upper-right	v = [grid originalVertex:d];	v.y -= diff.y;	v.z -= diff.z;	[grid setVertex:d vertex:v];}+(CGFloat)positiveAngle:(CGFloat)angle {    if (angle < 0.0f) {        angle = floorf(1-angle/2/M_PI)*2*M_PI + angle;    }    return angle;}+(NSString *)bundleVersion {    return [[[NSBundle mainBundle] infoDictionary] valueForKey:@"CFBundleVersion"];}@end