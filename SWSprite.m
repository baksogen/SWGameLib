////  SWSprite.m//  SWGameLib//////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 9/27/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWSprite.h"#import "CGPointExtension.h"#import "CCSpriteBatchNode.h"#import "ccTypes.h"#import "ccMacros.h"/** * IMPORT BEGINS * This portion came from the original CCSprite implementation. * Some are required. The other to suppress compiler warnings. */#if CC_SPRITEBATCHNODE_RENDER_SUBPIXEL#define RENDER_IN_SUBPIXEL#else#define RENDER_IN_SUBPIXEL(__A__) ( (int)(__A__))#endif// XXX: Optmizationstruct transformValues_ {	CGPoint pos;		// position x and y	CGPoint	scale;		// scale x and y	float	rotation;	CGPoint ap;			// anchor point in pixels};@interface CCSprite (Private)-(void)updateTextureCoords:(CGRect)rect;-(void)getTransformValues:(struct transformValues_ *)tv;@end/** * IMPORT ENDS */@interface SWSprite (Private)-(void)updateQuadVertices;@end@implementation SWSprite@synthesize qVertices = _relVetices;-(id)init {    if ((self = [super init])) {        _relVetices.bl = _relVetices.br = _relVetices.tl = _relVetices.tr = CGPointZero;    }    return self;}-(void)updateQuadVertices {    quad_.bl.vertices = (ccVertex3F) { _relVetices.bl.x, _relVetices.bl.y, quad_.bl.vertices.z };	quad_.br.vertices = (ccVertex3F) { _relVetices.br.x, _relVetices.br.y, quad_.br.vertices.z };	quad_.tl.vertices = (ccVertex3F) { _relVetices.tl.x, _relVetices.tl.y, quad_.tl.vertices.z };	quad_.tr.vertices = (ccVertex3F) { _relVetices.tr.x, _relVetices.tr.y, quad_.tr.vertices.z };}-(void) useSelfRender {	atlasIndex_ = CCSpriteIndexNotInitialized;	usesBatchNode_ = NO;	textureAtlas_ = nil;	batchNode_ = nil;	dirty_ = recursiveDirty_ = NO;		float x1 = 0 + offsetPosition_.x;	float y1 = 0 + offsetPosition_.y;	float x2 = x1 + rect_.size.width;	float y2 = y1 + rect_.size.height;    _relVetices.bl = ccp(x1, y1);    _relVetices.br = ccp(x2, y1);    _relVetices.tl = ccp(x1, y2);    _relVetices.tr = ccp(x2, y2);	    [self updateQuadVertices];}-(void)setTextureRect:(CGRect)rect rotated:(BOOL)rotated untrimmedSize:(CGSize)untrimmedSize{	rect_ = rect;	rectRotated_ = rotated;    	[self setContentSize:untrimmedSize];	[self updateTextureCoords:rect];    	CGPoint relativeOffset = unflippedOffsetPositionFromCenter_;		// issue #732	if( flipX_ )		relativeOffset.x = - relativeOffset.x;	if( flipY_ )		relativeOffset.y = - relativeOffset.y;		offsetPosition_.x = relativeOffset.x + (contentSize_.width - rect_.size.width) / 2;	offsetPosition_.y = relativeOffset.y + (contentSize_.height - rect_.size.height) / 2;			// rendering using SpriteSheet	if( usesBatchNode_ ) {		// update dirty_, don't update recursiveDirty_		dirty_ = YES;	}    	// self rendering	else	{		// Atlas: Vertex		float x1 = 0 + offsetPosition_.x;		float y1 = 0 + offsetPosition_.y;		float x2 = x1 + rect.size.width;		float y2 = y1 + rect.size.height;				// Don't update Z.        _relVetices.bl = ccp(x1, y1);        _relVetices.br = ccp(x2, y1);        _relVetices.tl = ccp(x1, y2);        _relVetices.tr = ccp(x2, y2);	        [self updateQuadVertices];	}    }-(void)updateTransform{	NSAssert( usesBatchNode_, @"updateTransform is only valid when CCSprite is being renderd using an CCSpriteBatchNode");    	CGAffineTransform matrix;			// Optimization: if it is not visible, then do nothing	if( ! visible_ ) {				quad_.br.vertices = quad_.tl.vertices = quad_.tr.vertices = quad_.bl.vertices = (ccVertex3F){0,0,0};		[textureAtlas_ updateQuad:&quad_ atIndex:atlasIndex_];		dirty_ = recursiveDirty_ = NO;		return ;	}	    	// Optimization: If parent is batchnode, or parent is nil	// build Affine transform manually	if( ! parent_ || parent_ == batchNode_ ) {				float radians = -CC_DEGREES_TO_RADIANS(rotation_);		float c = cosf(radians);		float s = sinf(radians);				matrix = CGAffineTransformMake( c * scaleX_,  s * scaleX_,									   -s * scaleY_, c * scaleY_,									   position_.x, position_.y);		matrix = CGAffineTransformTranslate(matrix, -anchorPointInPixels_.x, -anchorPointInPixels_.y);			} 		// else do affine transformation according to the HonorParentTransform	else if( parent_ != batchNode_ ) {        		matrix = CGAffineTransformIdentity;		ccHonorParentTransform prevHonor = CC_HONOR_PARENT_TRANSFORM_ALL;				for (CCNode *p = self ; p && p != batchNode_ ; p = p.parent) {						struct transformValues_ tv;			[(CCSprite*)p getTransformValues: &tv];						CGAffineTransform newMatrix = CGAffineTransformIdentity;						// 2nd: Translate, Rotate, Scale			if( prevHonor & CC_HONOR_PARENT_TRANSFORM_TRANSLATE )				newMatrix = CGAffineTransformTranslate(newMatrix, tv.pos.x, tv.pos.y);			if( prevHonor & CC_HONOR_PARENT_TRANSFORM_ROTATE )				newMatrix = CGAffineTransformRotate(newMatrix, -CC_DEGREES_TO_RADIANS(tv.rotation));			if( prevHonor & CC_HONOR_PARENT_TRANSFORM_SCALE ) {				newMatrix = CGAffineTransformScale(newMatrix, tv.scale.x, tv.scale.y);			}						// 3rd: Translate anchor point			newMatrix = CGAffineTransformTranslate(newMatrix, -tv.ap.x, -tv.ap.y);            			// 4th: Matrix multiplication			matrix = CGAffineTransformConcat( matrix, newMatrix);						prevHonor = [(CCSprite*)p honorParentTransform];		}			}		//	// calculate the Quad based on the Affine Matrix	//	    	float x = matrix.tx;	float y = matrix.ty;		float cr = matrix.a;	float sr = matrix.b;	float cr2 = matrix.d;	float sr2 = -matrix.c;    	float ax = _relVetices.bl.x * cr - _relVetices.bl.y * sr2 + x;	float ay = _relVetices.bl.x * sr + _relVetices.bl.y * cr2 + y;		float bx = _relVetices.br.x * cr - _relVetices.br.y * sr2 + x;	float by = _relVetices.br.x * sr + _relVetices.br.y * cr2 + y;		float cx = _relVetices.tr.x * cr - _relVetices.tr.y * sr2 + x;	float cy = _relVetices.tr.x * sr + _relVetices.tr.y * cr2 + y;		float dx = _relVetices.tl.x * cr - _relVetices.tl.y * sr2 + x;	float dy = _relVetices.tl.x * sr + _relVetices.tl.y * cr2 + y;		quad_.bl.vertices = (ccVertex3F) { RENDER_IN_SUBPIXEL(ax), RENDER_IN_SUBPIXEL(ay), vertexZ_ };	quad_.br.vertices = (ccVertex3F) { RENDER_IN_SUBPIXEL(bx), RENDER_IN_SUBPIXEL(by), vertexZ_ };	quad_.tl.vertices = (ccVertex3F) { RENDER_IN_SUBPIXEL(dx), RENDER_IN_SUBPIXEL(dy), vertexZ_ };	quad_.tr.vertices = (ccVertex3F) { RENDER_IN_SUBPIXEL(cx), RENDER_IN_SUBPIXEL(cy), vertexZ_ };    	[textureAtlas_ updateQuad:&quad_ atIndex:atlasIndex_];	dirty_ = recursiveDirty_ = NO;}@end