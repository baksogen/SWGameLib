////  SWNetworkObjectManager.m//  SWGameLib////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 9/7/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWNetworkObjectManager.h"#import "NSMutableArray+Sorting.h"#import "AsyncUdpSocket.h"#import "AsyncSocket.h"#import "ccTypes.h"#import "SWDebug.h"#import "CCScheduler.h"#import "SWPhysicsObject.h"#import "SWPacket.h"#import "SWDatagram.h"#import "SWMessage.h"#import "SWObjConstraint.h"#import "SWObjectTemplates.h"#import "chipmunk.h"#import "CGPointExtension.h"#import <CFNetwork/CFNetwork.h>#include <sys/socket.h>#include <netinet/in.h>#include <unistd.h>#define NET_SYNC_INTERVAL 1.0f/30.0f#define TCP_TIME_OUT      0.25f#define UDP_TIME_OUT      1.0f/30.0f#define POSITION_ERR_MAX  10.0f@interface SWDefaultObjectManager()@property (nonatomic, retain) NSMutableArray   *_events;@property (nonatomic, retain) NSMutableArray   *_spawningObjects;@property (nonatomic, retain) NSMutableArray   *_despawningObjects;@property (nonatomic, retain) NSMutableArray   *_spawnedObjects;@property (nonatomic, retain) NSOperationQueue *_opPEQueue;@property (nonatomic, retain) NSOperationQueue *_opEUQueue;-(void)_addToScene:(SWPhysicsObject *)obj;-(void)_removeFromScene:(SWPhysicsObject *)obj;-(void)_updateChipmunk;-(void)_updateEvents;-(void)_updateObject:(SWPhysicsObject *)obj;-(void)_spawnEntity:(SWPhysicsObject *)entity;-(void)_despawnEntity:(SWPhysicsObject *)entity;-(void)_update:(ccTime)elapsed;-(void)_initChipmunk;-(void)_pointQueryWithInfo:(NSDictionary *)info;-(void)_addEvent:(SWEvent *)event;-(void)_removeEvent:(SWEvent *)event;@end@interface SWNetworkObjectManager ()@property (nonatomic, retain) NSMutableArray   *_remoteObjects;@property (nonatomic, retain) NSOperationQueue *_netQueue;@property (nonatomic, retain) AsyncSocket      *_tcp;@property (nonatomic, retain) AsyncUdpSocket   *_udp;@property (nonatomic, retain) NSString         *_connectedHost;-(void)_pause;-(void)_resume;-(void)_setUpUdp;-(void)_tearDownUdp;-(void)_notifyObjectSpawn:(SWPhysicsObject *)obj;-(void)_notifyObjectDespawn:(SWPhysicsObject *)obj;-(void)_notifyObjectStates:(ccTime)dt;-(void)__notifyObjectStates;-(void)_processIncomingEvents:(SWPacket *)p;-(void)_updateRemoteObject:(SWObjectStateDatagram *)d;-(void)_spawnRemoteEntity:(SWPacketObjectSpawn *)entity;-(void)_despawnRemoteEntity:(SWPacketObjectDespawn *)entity;@end@implementation SWNetworkObjectManager@synthesize _netQueue;@synthesize _tcp;@synthesize _udp;@synthesize _connectedHost;@synthesize _remoteObjects;@synthesize playerIdx = _pIdx;@synthesize handler   = _handler;@synthesize netQueue;+(id)manager {    @throw [NSException exceptionWithName:NSInternalInconsistencyException                                   reason:@"Use managerWithAsyncSocket: instead"                                 userInfo:nil];}+(id)managerWithAsyncSocket:(AsyncSocket *)socket {    return [[[self alloc] initWithAsyncSocket:socket] autorelease];}-(id)init {    @throw [NSException exceptionWithName:NSInternalInconsistencyException                                   reason:@"Use initWithAsyncSocket: instead"                                 userInfo:nil];}-(id)initWithAsyncSocket:(AsyncSocket *)socket {    if ((self = [super init])) {        _netQueue = [[NSOperationQueue alloc] init];        _netOp    = nil;                [_netQueue setSuspended:YES];        [_netQueue setMaxConcurrentOperationCount:1];                self._tcp = socket;        _pIdx     = _rIdx = 0;                _connectedHost = [[socket connectedHost] retain];        _connectedPort = [socket connectedPort];        _remoteObjects = [[NSMutableArray alloc] init];                [[CCScheduler sharedScheduler] scheduleSelector:@selector(_notifyObjectStates:)                                              forTarget:self                                               interval:NET_SYNC_INTERVAL                                                 paused:YES];    }    return self;}-(void)dealloc {    [[CCScheduler sharedScheduler] unscheduleSelector:@selector(_notifyObjectStates:)                                            forTarget:self];    [_connectedHost release];    [_remoteObjects release];    [_tcp release];    [_udp release];    [_netQueue release];    [super dealloc];}#pragma mark -#pragma mark Properties-(NSOperationQueue *)netQueue {    return _netQueue;}-(void)setPlayerIdx:(NSUInteger)p {    if (p == 1) {        _rIdx = 2;        _pIdx = 1;    } else {        _rIdx = 1;        _pIdx = 2;    }}#pragma mark -#pragma mark SWDefaultObjectManager-(void)onEnter {    if ([_tcp canSafelySetDelegate] && [_tcp delegate] != self) {        [_tcp setDelegate:self];    } else {        @throw [NSException exceptionWithName:NSInternalInconsistencyException                                       reason:@"flush tcp connection before using for SWNetworkObjectManager."                                     userInfo:nil];    }        SWAssert(_rIdx != 0 && _pIdx != 0, @"Player index is not set.");    SWAssert(self.templates, @"There is no object template set.");        [super onEnter];    if ([_tcp isConnected]) {        [_tcp readDataToLength:sizeof(NSUInteger) withTimeout:-1 tag:0];    }    if ([_handler respondsToSelector:@selector(connectionReady:)]) {        [_handler connectionReady:self];    }}-(void)onExit {    [super onExit];        while (_netOp) {}        for (SWPhysicsObject *obj in _remoteObjects) {        cpBody  *body;        cpShape *shape;        cpSpace *space;                space  = [self physicalSpace];        shape  = obj.shape;        body   = shape->body;                for (SWObjConstraint *c in [obj constraints]) {            cpSpaceRemoveConstraint(space, c.constraint);        }                if (shape) {            if (cpBodyGetMoment(body) == INFINITY &&                cpBodyGetMass(body)   == INFINITY) {                cpSpaceRemoveStaticShape(space, shape);            } else {                cpSpaceRemoveBody(space, body);                cpSpaceRemoveShape(space, shape);            }        }    }        [_remoteObjects removeAllObjects];}-(void)resume:(id)sender {    [super resume:sender];    [_netQueue setSuspended:NO];        if ([_tcp isConnected]) {        [self _setUpUdp];        if (sender != self) {            [self _resume];            }    }}-(void)_resume {    SWPacket *packet;        packet      = [[SWPacket alloc] init];    packet.type = SWEventIDResume;        [_tcp writeData:[packet packet] withTimeout:TCP_TIME_OUT tag:0];        [packet release];}-(void)pause:(id)sender {    if (sender != self) {        [self _pause];    }    [self _tearDownUdp];    [_netQueue setSuspended:YES];        while (_netOp) {}        [super pause:sender];}-(void)_pause {    SWPacket *packet;        packet      = [[SWPacket alloc] init];    packet.type = SWEventIDPause;        [_tcp writeData:[packet packet] withTimeout:TCP_TIME_OUT tag:0];        [packet release];}#pragma mark -#pragma mark Connection Management-(void)_setUpUdp {    NSError *err;        err = nil;        self._udp = [[[AsyncUdpSocket alloc] initWithDelegate:self] autorelease];        if ([_udp bindToPort:[_tcp localPort] error:&err]) {        SWLog(@"udp connection successfully established.");    } else {        SWLog(@"%@", err);    }        [_udp receiveWithTimeout:-1 tag:0];}-(void)_tearDownUdp {    [_udp closeAfterSending];    [_udp setDelegate:nil];    [_udp release];    _udp = nil;}#pragma mark -#pragma mark Synchronization-(void)spawnEntity:(SWPhysicsObject *)entity {    [super spawnEntity:entity];    if (entity.objectID != 0 && entity.playerIdx == _pIdx) {        [_netQueue addOperation:[[[NSInvocationOperation alloc] initWithTarget:self                                                                      selector:@selector(_notifyObjectSpawn:)                                                                        object:entity] autorelease]];    }}-(void)despawnEntity:(SWPhysicsObject *)entity {    if (entity.spawnManager == self && entity.playerIdx == _pIdx) {        [_netQueue addOperation:[[[NSInvocationOperation alloc] initWithTarget:self                                                                      selector:@selector(_notifyObjectDespawn:)                                                                        object:entity] autorelease]];    }    [super despawnEntity:entity];}-(void)_spawnRemoteEntity:(SWPacketObjectSpawn *)p {    SWPhysicsObject *entity;    NSDate          *now;        now    = [NSDate date];    entity = [NSClassFromString(p.templateKey) performSelector:@selector(objectWithTemplate:)                                                     withObject:[self.templates templateWithName:p.templateKey]];        entity.lastUpdate = [now timeIntervalSince1970];    entity.position   = p.position;    entity.objectID   = p.objectID;        if (![_remoteObjects objectWithObjectID:entity.objectID]) {        cpBody  *body;        cpShape *shape;        cpSpace *space;                space  = [self physicalSpace];        shape  = entity.shape;        body   = shape->body;                if (shape) {            if (cpBodyGetMoment(body) == INFINITY &&                cpBodyGetMass(body)   == INFINITY) {                shape->group = 0;                cpSpaceAddStaticShape(space, shape);            } else {                cpSpaceAddBody(space, body);                cpSpaceAddShape(space, shape);            }            for (SWObjConstraint *c in [entity constraints]) {                SWAssert([c retainCount] == 1, @"There is more than one parent for a constraint!");                cpSpaceAddConstraint(space, c.constraint);            }        }                [self performSelectorOnMainThread:@selector(_addToScene:) withObject:entity waitUntilDone:NO];        [_remoteObjects insertSortedObject:entity];    }}-(void)_despawnRemoteEntity:(SWPacketObjectDespawn *)p {    SWPhysicsObject *entity;        if ((entity = (SWPhysicsObject *)[_remoteObjects objectWithObjectID:p.objectID])) {        cpBody  *body;        cpShape *shape;        cpSpace *space;                space  = [self physicalSpace];        shape  = entity.shape;        body   = shape->body;                [self performSelectorOnMainThread:@selector(_removeFromScene:) withObject:entity waitUntilDone:NO];        [_remoteObjects removeSortedObject:entity];                if (shape) {            for (SWObjConstraint *c in [entity constraints]) {                cpSpaceRemoveConstraint(space, c.constraint);            }            if (cpBodyGetMoment(body) == INFINITY &&                cpBodyGetMass(body)   == INFINITY) {                cpSpaceRemoveStaticShape(space, shape);            } else {                cpSpaceRemoveBody(space, body);                cpSpaceRemoveShape(space, shape);            }        }    }}-(void)_notifyObjectSpawn:(SWPhysicsObject *)obj {    SWPacketObjectSpawn *os;        os = [[SWPacketObjectSpawn alloc] init];        os.type        = ObjectEventSpawn;    os.objectID    = obj.objectID;    os.templateKey = obj.templateKey;    os.position    = obj.position;        [_tcp writeData:[os packet]         withTimeout:TCP_TIME_OUT                tag:0];}-(void)_notifyObjectDespawn:(SWPhysicsObject *)obj {    SWPacketObjectDespawn *od;        od = [[SWPacketObjectDespawn alloc] init];        od.type     = ObjectEventDespawn;    od.objectID = obj.objectID;        [_tcp writeData:[od packet]        withTimeout:TCP_TIME_OUT                tag:0];}-(void)_notifyObjectStates:(ccTime)dt {    if (!_netOp) {        _netOp = [[NSInvocationOperation alloc] initWithTarget:self                                                      selector:@selector(__notifyObjectStates)                                                        object:nil];        [_netQueue addOperation:_netOp];        [_netOp release];    }}-(void)__notifyObjectStates {    @synchronized(self._spawnedObjects) {        for (SWPhysicsObject *obj in self._spawnedObjects) {            if (obj.playerIdx == _pIdx) {                SWObjectStateDatagram *osd;                                osd = [[SWObjectStateDatagram alloc] init];                                if (obj.shape && obj.shape->body) {                    cpBody *body = obj.shape->body;                                        osd.objectID        = obj.objectID;                    osd.angle           = cpBodyGetAngle(body);                    osd.angularVelocity = cpBodyGetAngVel(body);                    osd.linearVelocity  = cpBodyGetVel(body);                    osd.position        = cpBodyGetPos(body);                                        [_udp sendData:[osd packet]                             toHost:_connectedHost                               port:_connectedPort                       withTimeout:UDP_TIME_OUT                               tag:0];                }                [osd release];            }        }    }    _netOp = nil;}-(void)_processIncomingEvents:(SWPacket *)p {    if (p.type == ObjectEventDespawn) {        SWPacketObjectDespawn *od;                od = [[SWPacketObjectDespawn alloc] initWithData:[p packet]];                [self.opPEQueue addOperation:[[[NSInvocationOperation alloc] initWithTarget:self                                                                       selector:@selector(_despawnRemoteEntity:)                                                                         object:od] autorelease]];        [od release];    } else if (p.type == ObjectEventSpawn) {        SWPacketObjectSpawn *os;                os = [[SWPacketObjectSpawn alloc] initWithData:[p packet]];                [self.opPEQueue addOperation:[[[NSInvocationOperation alloc] initWithTarget:self                                                                       selector:@selector(_spawnRemoteEntity:)                                                                         object:os] autorelease]];        [os release];    } else {        [self addEvent:[self eventWithID:p.type]];    }}-(void)_updateRemoteObject:(SWObjectStateDatagram *)d {    SWPhysicsObject *obj;        if ((obj = (SWPhysicsObject *)[_remoteObjects objectWithObjectID:d.objectID])) {        if ([d isValid:obj.lastUpdate]) {                        obj.linearVelocity  = ccpMult(ccpSub(d.linearVelocity, obj.linearVelocity), 0.5f);            obj.position        = ccpMult(ccpAdd(obj.position, d.position), 0.5f);            obj.angularVelocity = (obj.angularVelocity+d.angularVelocity)*0.5f;            obj.rotation        = (obj.rotation+d.angle)*0.5f;                        if (ccpDistance(obj.position, d.position) > POSITION_ERR_MAX) {                obj.position = d.position;            }        }    }}-(void)_updateObject:(SWPhysicsObject *)obj {    if (obj.spawnManager && obj.playerIdx == _pIdx) {        [obj update];    }}#pragma mark -#pragma mark AsyncSocket Delegate- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err {    SWLog(@"%@", err);    if ([_handler respondsToSelector:@selector(connectionLost:)]) {        [_handler connectionLost:self];    }}- (void)onSocketDidDisconnect:(AsyncSocket *)sock {    // XXX: ignored. TCP connection should be alive during the entire lifecycle of this object.}- (void)onSocket:(AsyncSocket *)sock didAcceptNewSocket:(AsyncSocket *)newSocket {    // XXX: do nothing. there is no intention of creating extra tcp connections.}- (NSRunLoop *)onSocket:(AsyncSocket *)sock wantsRunLoopForNewSocket:(AsyncSocket *)newSocket {    METHOD_EXIT();    return nil; // XXX: this should not be called. }- (BOOL)onSocketWillConnect:(AsyncSocket *)sock {    METHOD_EXIT();    return NO; // XXX:  once connection is dropped. recover from the beginning freshly.}- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port {    // XXX: once connection is dropped. recover from the beginning freshly.}- (void)onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag {    if (tag == 0) {        NSUInteger len;                memcpy(&len, [data bytes], sizeof(NSUInteger));                [sock readDataToLength:len withTimeout:0.5f tag:1];    } else {        SWPacket *packet;                packet = [[SWPacket alloc] initWithData:data];                [_netQueue addOperation:[[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(_processIncomingEvents:) object:packet] autorelease]];                [packet release];        [sock readDataToLength:sizeof(NSUInteger) withTimeout:-1 tag:0];    }}- (void)onSocket:(AsyncSocket *)sock didReadPartialDataOfLength:(CFIndex)partialLength tag:(long)tag {    // drop all partial data.}- (void)onSocket:(AsyncSocket *)sock didWriteDataWithTag:(long)tag {    }- (void)onSocket:(AsyncSocket *)sock didWritePartialDataOfLength:(CFIndex)partialLength tag:(long)tag {    }- (NSTimeInterval)onSocket:(AsyncSocket *)sock  shouldTimeoutReadWithTag:(long)tag				   elapsed:(NSTimeInterval)elapsed				 bytesDone:(CFIndex)length {    return 0; // no timeout extension. just raise an error}- (NSTimeInterval)onSocket:(AsyncSocket *)sock shouldTimeoutWriteWithTag:(long)tag				   elapsed:(NSTimeInterval)elapsed				 bytesDone:(CFIndex)length {    return 0; // no timeout extension, just raise an error}- (void)onSocketDidSecure:(AsyncSocket *)sock {}#pragma mark -#pragma mark AsyncUdpSocket Delegate- (void)onUdpSocket:(AsyncUdpSocket *)sock didSendDataWithTag:(long)tag {    }- (void)onUdpSocket:(AsyncUdpSocket *)sock didNotSendDataWithTag:(long)tag dueToError:(NSError *)error {    SWLog(@"%@", error);}- (BOOL)onUdpSocket:(AsyncUdpSocket *)sock didReceiveData:(NSData *)data withTag:(long)tag fromHost:(NSString *)host port:(UInt16)port {    if ([host isEqualToString:_connectedHost] && port == _connectedPort &&        [data length] == sizeof(NSUInteger)+sizeof(CGFloat)*6) {        SWObjectStateDatagram *osd;                osd = [[SWObjectStateDatagram alloc] initWithData:data];                [self.opPEQueue addOperation:[[[NSInvocationOperation alloc] initWithTarget:self                                                                           selector:@selector(_updateRemoteObject:)                                                                             object:osd] autorelease]];                [osd release];        [sock receiveWithTimeout:-1 tag:0];        return YES;    }    return NO;}- (void)onUdpSocket:(AsyncUdpSocket *)sock didNotReceiveDataWithTag:(long)tag dueToError:(NSError *)error {    SWLog(@"%@", error);}- (void)onUdpSocketDidClose:(AsyncUdpSocket *)sock {    }#pragma mark -#pragma mark Helper+(UInt16)availablePort {    // XXX: this is copied from an Apple's example.        CFSocketRef _ipv4socket;    UInt16      _port;    CFSocketContext socketCtxt = {0, self, NULL, NULL, NULL};    _ipv4socket = CFSocketCreate(kCFAllocatorDefault, PF_INET, SOCK_STREAM, IPPROTO_TCP, kCFSocketAcceptCallBack, NULL, &socketCtxt);	    if (NULL == _ipv4socket) {        if (_ipv4socket) CFRelease(_ipv4socket);        _ipv4socket = NULL;        return 0;    }		    int yes = 1;    setsockopt(CFSocketGetNative(_ipv4socket), SOL_SOCKET, SO_REUSEADDR, (void *)&yes, sizeof(yes));	    struct sockaddr_in addr4;    memset(&addr4, 0, sizeof(addr4));    addr4.sin_len = sizeof(addr4);    addr4.sin_family = AF_INET;    addr4.sin_port = 0;    addr4.sin_addr.s_addr = htonl(INADDR_ANY);    NSData *address4 = [NSData dataWithBytes:&addr4 length:sizeof(addr4)];	    if (kCFSocketSuccess != CFSocketSetAddress(_ipv4socket, (CFDataRef)address4)) {        if (_ipv4socket) CFRelease(_ipv4socket);        _ipv4socket = NULL;        return 0;    }    	NSData *addr = [(NSData *)CFSocketCopyAddress(_ipv4socket) autorelease];	memcpy(&addr4, [addr bytes], [addr length]);	_port = ntohs(addr4.sin_port);		CFSocketInvalidate(_ipv4socket);    CFRelease(_ipv4socket);    _ipv4socket = NULL;        return _port;}@end