////  SWTableView.m//  SWGameLib////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  ////  Created by Sangwoo Im on 6/3/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWTableView.h"#import "SWTableViewCell.h"#import "CCMenu.h"#import "CGPointExtension.h"#import "NSMutableArray+Sorting.h"#import "CCLayer.h"#import "SWDebug.h"@interface SWScrollView()@property (nonatomic, assign) BOOL    touchMoved_;@property (nonatomic, retain) CCLayer *container_;@property (nonatomic, assign) CGPoint touchPoint_;@end@interface SWTableView ()-(NSUInteger)_indexFromOffset:(CGPoint)offset;-(CGPoint)_offsetFromIndex:(NSUInteger)index;-(void)_updateContentSize;@end@interface SWTableView (Private)- (SWTableViewCell *)_cellWithIndex:(NSUInteger)cellIndex;- (void)_moveCellOutOfSight:(SWTableViewCell *)cell;- (void)_setIndex:(NSUInteger)index forCell:(SWTableViewCell *)cell;- (void)_addCellIfNecessary:(SWTableViewCell *)cell;@end@implementation SWTableView@synthesize delegate   = tDelegate_;@synthesize dataSource = dataSource_;+(id)viewWithDataSource:(id<SWTableViewDataSource>)dataSource size:(CGSize)size {    return [self viewWithDataSource:dataSource size:size container:nil];}+(id)viewWithDataSource:(id <SWTableViewDataSource>)dataSource size:(CGSize)size container:(CCNode *)container {    SWTableView *table;    table = [[[self alloc] initWithViewSize:size container:container] autorelease];    table.dataSource = dataSource;    [table _updateContentSize];    return table;}-(id)initWithViewSize:(CGSize)size container:(CCNode *)container {    if ((self = [super initWithViewSize:size container:container])) {        cellsUsed_      = [NSMutableArray new];        cellsFreed_     = [NSMutableArray new];        tDelegate_      = nil;        self.direction  = SWScrollViewDirectionVertical;                [super setDelegate:self];    }    return self;}#pragma mark -#pragma mark public-(void)reloadData {    NSAutoreleasePool *pool;        pool = [NSAutoreleasePool new];    for (SWTableViewCell *cell in cellsUsed_) {        [cellsFreed_ addObject:cell];        cell.idx            = NSNotFound;        cell.node.visible   = NO;    }    [cellsUsed_ release];    cellsUsed_ = [NSMutableArray new];        [self _updateContentSize];    if ([dataSource_ numberOfCellsInTableView:self] > 0) {        [self scrollViewDidScroll:self];    }    [pool drain];}-(void)updateCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        SWLog(@"%s: %s: invalid index", __FILE__, __FUNCTION__);        return;    }        SWTableViewCell   *cell;        cell = [self _cellWithIndex:idx];    if (cell) {        [self _moveCellOutOfSight:cell];    }     cell = [dataSource_ table:self cellAtIndex:idx];    [self _addCellIfNecessary:cell];    [self _setIndex:idx forCell:cell];    [cellsUsed_ insertSortedCell:cell];}-(void)insertCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        SWLog(@"%s: %s: invalid index", __FILE__, __FUNCTION__);        return;    }    NSArray           *movingCells;    NSPredicate       *pred;    SWTableViewCell   *cell;    NSUInteger        newIdx;        pred        = [NSPredicate predicateWithFormat:@"idx >= %i",idx];    movingCells = [cellsUsed_ filteredArrayUsingPredicate:pred];        //Pushing existing cells down.    for (SWTableViewCell *tCell in movingCells) {        newIdx = cell.idx + 1;        [self _setIndex:newIdx forCell:tCell];    }        //insert a new cell    cell = [dataSource_ table:self cellAtIndex:idx];    [self _addCellIfNecessary:cell];    [self _setIndex:idx forCell:cell];    [cellsUsed_ insertSortedCell:cell];        [self _updateContentSize];}-(void)removeCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        SWLog(@"%s: %s: invalid index", __FILE__, __FUNCTION__);        return;    }        SWTableViewCell   *cell;    NSUInteger        newIdx;    NSArray           *movingCells;    NSPredicate       *pred;        cell = [self _cellWithIndex:idx];    if (!cell) {        return;    }    //remove first    [self _moveCellOutOfSight:cell];        //pulling cells up    pred        = [NSPredicate predicateWithFormat:@"idx > %i", idx];    movingCells = [cellsUsed_ filteredArrayUsingPredicate:pred];        for (cell in movingCells) {        newIdx = cell.idx - 1;        [self _setIndex:newIdx forCell:cell];    }}-(SWTableViewCell *)dequeueCell {    SWTableViewCell *cell;        if ([cellsFreed_ count] == 0) {        cell = nil;    } else {        cell = [[cellsFreed_ objectAtIndex:0] retain];        [cellsFreed_ removeObjectAtIndex:0];    }    return [cell autorelease];}#pragma mark -#pragma mark private- (void)_addCellIfNecessary:(SWTableViewCell *)cell {    if (cell.node.parent != self.container_) {        SWAssert(!cell.node.parent, @"CCTableView: _addCellIfNecessary: cell from another table view is returned from data source");          [self.container_ addChild:cell.node];    }}- (void)_updateContentSize {    CGSize     size, cellSize;    NSUInteger cellCount;        cellSize  = [dataSource_ cellSizeForTable:self];    cellCount = [dataSource_ numberOfCellsInTableView:self];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            size = CGSizeMake(cellCount * cellSize.width, self.viewSize.height);            if (size.width < self.viewSize.width) {                size.width = self.viewSize.width;            }            break;        default:            size = CGSizeMake(self.viewSize.width, cellCount * cellSize.height);            if (size.height < self.viewSize.height) {                size.height = self.viewSize.height;            }            break;    }    [self setContentSize:size];}- (CGPoint)_offsetFromIndex:(NSUInteger)index {    CGPoint offset;    CGSize  cellSize;        SWAssert(index != NSNotFound, @"CCTableView: _offsetFromIndex: invalid index");        cellSize = [dataSource_ cellSizeForTable:self];    switch (self.direction) {        case SWScrollViewDirectionHorizontal:            offset = ccp(cellSize.width * index, 0.0f);            break;        default:            offset = ccp(0.0f, cellSize.height * index);            break;    }        return offset;}- (NSUInteger)_indexFromOffset:(CGPoint)offset {    NSInteger  index;    CGSize     cellSize;        cellSize = [dataSource_ cellSizeForTable:self];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            index = offset.x/cellSize.width;            break;        default:            index = offset.y/cellSize.height;            break;    }        index = MAX(0, index);    index = MIN(((NSInteger)[dataSource_ numberOfCellsInTableView:self])-1, index);    return ((NSUInteger)index);}- (SWTableViewCell *)_cellWithIndex:(NSUInteger)cellIndex {    return [cellsUsed_ cellWithIdx:cellIndex];}- (void)_moveCellOutOfSight:(SWTableViewCell *)cell {    [cellsFreed_ addObject:cell];    [cellsUsed_ removeSortedCell:cell];    [self.container_ removeChild:cell.node cleanup:YES];    cell.idx       = NSNotFound;    cell.node      = nil;}- (void)_setIndex:(NSUInteger)index forCell:(SWTableViewCell *)cell {    CGPoint    offset;    CGSize     cellSize;    CCNode     *item;    SWAssert(cell != nil, @"CCTableView: _setIndex:forCell: cell is nil!");        offset   = [self _offsetFromIndex:index];    cellSize = [dataSource_ cellSizeForTable:self];        if (!CGSizeEqualToSize(cell.node.contentSize, cellSize)) {        SWLog(@"%s: %s: inconsistent cell size", __FILE__, __FUNCTION__);    }        item             = cell.node;    item.anchorPoint = ccp(0.0f, 0.0f);    item.position    = offset;    cell.idx         = index;}#pragma mark -#pragma mark scrollView-(void)scrollViewDidScroll:(SWScrollView *)view {    NSUInteger        startIdx, endIdx;    CGSize            cellSize;    NSMutableArray    *clippedCells;    CGPoint           offset;    NSAutoreleasePool *pool;    NSRange           clipRange;        pool     = [NSAutoreleasePool new];    offset   = [self contentOffset];    offset   = ccp(-offset.x, -offset.y);    cellSize = [dataSource_ cellSizeForTable:self];    startIdx = [self _indexFromOffset:offset];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            offset.x += self.viewSize.width;            offset.y =  self.viewSize.height;            break;        default:            offset.x =  self.viewSize.width;            offset.y += self.viewSize.height;            break;    }    endIdx = [self _indexFromOffset:offset];        clipRange.location = 0;    clipRange.length   = [cellsUsed_ indexOfSortedCell:[cellsUsed_ cellWithIdx:startIdx]];        clippedCells = [NSMutableArray arrayWithCapacity:clipRange.length];        for (NSUInteger i = clipRange.location; i < clipRange.length; i++) {        [clippedCells addObject:[cellsUsed_ objectAtIndex:i]];    }        for (SWTableViewCell *cell in clippedCells) {        [self _moveCellOutOfSight:cell];    }        clipRange.location = [cellsUsed_ indexOfSortedCell:[cellsUsed_ cellWithIdx:endIdx]]+1;    clipRange.length   = MAX([dataSource_ numberOfCellsInTableView:self]-clipRange.location, 0);        clippedCells = [NSMutableArray arrayWithCapacity:clipRange.length];        if (clipRange.location < [cellsUsed_ count]-1) {        for (NSUInteger i=clipRange.location; clipRange.location+clipRange.length; i++) {            [clippedCells addObject:[cellsUsed_ objectAtIndex:i]];        }        }        for (SWTableViewCell *cell in clippedCells) {        [self _moveCellOutOfSight:cell];    }        for (NSUInteger i=startIdx; i <= endIdx; i++) {        if ([self _cellWithIndex:i]) {            continue;        }        [self updateCellAtIndex:i];    }    SWLog(@"%s: %s: cells in use: %i", __FILE__, __FUNCTION__, [cellsUsed_ count]);    SWLog(@"%s: %s: cells in free list: %i", __FILE__, __FUNCTION__, [cellsFreed_ count]);    [pool drain];}#pragma mark -#pragma mark Touch events-(void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {    if (!self.visible || !self.isEnabled) {        return;    }    if ([touches count] == 1 && !self.touchMoved_ &&        !CGPointEqualToPoint(ccp(-1.0f, -1.0f), self.touchPoint_)) {        CGPoint           localPoint;        NSUInteger        index;        SWTableViewCell   *cell;                localPoint = [self contentOffset];        localPoint = ccpAdd(ccp(-localPoint.x, -localPoint.y), self.touchPoint_);        index      = [self _indexFromOffset:localPoint];        cell       = [self _cellWithIndex:index];                SWAssert(cell, @"CCTableView: no cell exists with that index");                [tDelegate_ table:self cellTouched:cell];    }    [super ccTouchesEnded:touches withEvent:event];}#pragma mark -#pragma mark dealloc-(void)dealloc {    [cellsUsed_  release];    [cellsFreed_ release];    [super dealloc];}@end