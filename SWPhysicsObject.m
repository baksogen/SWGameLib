////  SWPhysicsObject.m//  SWGameLib//////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 4/19/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWPhysicsObject.h"#import "SWDefaultObjectManager.h"#import "ccMacros.h"#import "CGPointExtension.h"#import "SWDebug.h"#define SWObjPosition @"CGPoint"#define SWObjTime     @"CGFloat"@implementation SWPhysicsObject@dynamic mass;@dynamic friction;@dynamic elasticity;@dynamic linearVelocity;@dynamic angularVelocity;@dynamic collisionLayers;@dynamic constraints;@synthesize lastContactPoint = _lastContactPoint;@synthesize shape            = _shape;@synthesize spawnManager     = _spawnManager;@synthesize parent           = _parent;@synthesize enablePosUpdate  = _enablePosUpdate;@synthesize enableRotUpdate  = _enableRotUpdate;@synthesize shadow           = _shadow;@synthesize zHeight          = _zHeight;@synthesize lastUpdate       = _lastUpdate;-(id)initWithTemplate:(NSDictionary *)info {    if ((self = [super initWithTemplate:info])) {        cpBody  *body;        cpFloat momentBox;        cpFloat length, width, height;                _constraints = [NSMutableArray new];                if (info) {            width  = self.sprite.contentSize.width;            height = self.sprite.contentSize.height;            if (width < height) {                length = width;            } else {                length = height;            }                        momentBox       = cpMomentForBox(1, self.sprite.contentSize.width, self.sprite.contentSize.height);            body            = cpBodyNew(1, momentBox);            _shape          = cpCircleShapeNew(body, length*0.4, CGPointZero);            _shape->data    = self;            _shape->u       = 0.5;            _shape->e       = 0.5;            _spawnManager   = nil;                _shadow         = nil;            _zHeight        = 0.0f;        }        _enablePosUpdate = YES;        _enableRotUpdate = YES;        _lastUpdate      = 0;    }    return self;}-(void)dealloc {    cpBodyFree(_shape->body);    cpShapeFree(_shape);    [_shadow      release];    [_constraints release];    [super dealloc];}-(void)spawnOnCurrentThread {    SWAssert(_spawnManager, @"there is no spawn manager set.");    [_spawnManager spawnEntity:self];}-(void)despawnOnCurrentThread {    if (_spawnManager) {        [_spawnManager despawnEntity:self];        _parent = nil;    }}-(void)spawn {    [self performSelectorOnMainThread:@selector(spawnOnCurrentThread)                           withObject:nil                        waitUntilDone:NO];}-(void)despawn {    [self performSelectorOnMainThread:@selector(despawnOnCurrentThread)                           withObject:nil                        waitUntilDone:NO];}-(void)playAnimation:(NSString *)key {    [super performSelectorOnMainThread:@selector(playAnimation:)                            withObject:key                         waitUntilDone:NO];}-(void)playAnimation:(NSString *)key repeat:(NSInteger)repeat {    [super performSelectorOnMainThread:@selector(playAnimation:repeat:)                            withObject:key                         waitUntilDone:NO];}-(void)stopAnimation:(NSString *)key {    [super performSelectorOnMainThread:@selector(stopAnimation:)                            withObject:key                         waitUntilDone:NO];}-(void)playSFX:(NSString *)key {    [super performSelectorOnMainThread:@selector(playSFX:)                            withObject:key                         waitUntilDone:NO];}-(void)applyForce:(cpVect)f {    cpBodyApplyForce(_shape->body, f, ccp(0,0));}-(void)resetForce {    cpBodyResetForces(_shape->body);}-(void)moveTo:(CGPoint)pos inTime:(CGFloat)dt {    cpBodySlew(_shape->body, pos, dt);}#pragma mark -#pragma mark properties-(NSArray *)constraints {    return _constraints;}-(cpFloat)mass {    return cpBodyGetMass(_shape->body);}-(cpFloat)friction {    return _shape->u;}-(cpFloat)elasticity {    return _shape->e;}-(CGPoint)position {    return self.sprite.position;}-(CGFloat)rotation {    return CC_DEGREES_TO_RADIANS(self.sprite.rotation);}-(cpVect)linearVelocity {    return cpBodyGetVel(_shape->body);}-(cpFloat)angularVelocity {    return cpBodyGetAngVel(_shape->body);}-(cpLayers)collisionLayers {    return _shape->layers;}-(void)setPosition:(CGPoint)pos {    self.sprite.position = pos;    cpBodySetPos(_shape->body, pos);}-(void)setRotation:(CGFloat)rot {    self.sprite.rotation = CC_RADIANS_TO_DEGREES(-rot);    cpBodySetAngle(_shape->body, rot);}-(void)setLinearVelocity:(cpVect)val {    cpBodySetVel(_shape->body, val);}-(void)setAngularVelocity:(cpFloat)val {    cpBodySetAngVel(_shape->body, val);}-(void)setCollisionLayers:(cpLayers)val {    _shape->layers = val;}#pragma mark -#pragma mark periodic updates-(void)update {    if (self.spawnManager) {        if (_enablePosUpdate) {            self.sprite.position = cpBodyGetPos(_shape->body);        }        if (_enableRotUpdate) {            self.sprite.rotation = CC_RADIANS_TO_DEGREES(-cpBodyGetAngle(_shape->body));        }                if (_shadow && self.sprite) {            if (_zHeight < 0.0f) {                _shadow.visible = NO;            } else {                CGPoint offset;                CGFloat d, a;                GLubyte o;                                _shadow.visible  = YES;                _shadow.rotation = self.sprite.rotation;                                offset = ccpSub(self.position, self.spawnManager.lightSource);                                d = ccpLength(offset);                a = atanf(d/(LIGHT_DISTANCE-_zHeight));                d = tanf(a)*LIGHT_DISTANCE;                o = (GLubyte) MAX(255-_zHeight,0);                 a = 1.0f+_zHeight/255;                                _shadow.position = ccpAdd(ccpMult(ccpNormalize(offset), d), self.spawnManager.lightSource);                _shadow.opacity  = o;                _shadow.scale    = a;            }        }    }}#pragma mark -#pragma mark Collisions-(BOOL)beginCollisionWithPoint:(CGPoint)p object:(SWPhysicsObject *)obj {    return NO;}-(BOOL)afterEffectsExist:(SWPhysicsObject *)obj {    return NO;}-(void)processAfterEffectsWithObject:(SWPhysicsObject *)obj {    }-(void)endCollisionWithObject:(SWPhysicsObject *)obj {    }@end