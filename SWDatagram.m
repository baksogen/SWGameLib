////  SWDatagram.m//  SWGameLib////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  //  Created by Sangwoo Im on 9/29/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "SWDatagram.h"@interface SWDatagram ()@property (nonatomic, retain) NSData *userData;@end@implementation SWDatagram@synthesize userData = _userData;-(id)init {    if ((self = [super init])) {        _userData = nil;    }    return self;}-(id)initWithData:(NSData *)data {    if ((self = [super init])) {        NSUInteger read;                read = sizeof(NSTimeInterval);        memcpy(&_timeStamp, [data bytes], read);                self.userData = [NSData dataWithBytes:[data bytes]+read                                       length:[data length]-read];    }    return self;}-(BOOL)isValid:(NSTimeInterval)latestUpdateTime {    return _timeStamp > latestUpdateTime;}-(NSData *)packet {    NSDate        *now;    NSMutableData *data;        now        = [[NSDate alloc] init];    _timeStamp = [now timeIntervalSince1970];    data       = [NSMutableData dataWithBytes:&_timeStamp length:sizeof(NSTimeInterval)];        return data;}@end@implementation SWObjectStateDatagram@synthesize force           = _force;@synthesize linearVelocity  = _linearVelocity;@synthesize position        = _position;@synthesize angularVelocity = _angularVelocity; @synthesize angle           = _angle;@synthesize objectID        = _objectID;-(id)initWithData:(NSData *)data {    if ((self = [super initWithData:data])) {        const NSUInteger size  = sizeof(CGFloat);        const NSUInteger iSize = sizeof(NSUInteger);                memcpy(&_objectID, [self.userData bytes], iSize);        memcpy(&_linearVelocity, [self.userData bytes]+iSize, size*2);        memcpy(&_position, [self.userData bytes]+iSize+size*2, size*2);        memcpy(&_angularVelocity, [self.userData bytes]+iSize+size*4, size);        memcpy(&_angle, [self.userData bytes]+iSize+size*5, size);    }    return self;}-(NSData *)packet {    NSMutableData *data;        const NSUInteger size = sizeof(CGFloat);        data = (NSMutableData *)[super packet];        [data appendBytes:&_objectID length:sizeof(NSUInteger)];    [data appendBytes:&_linearVelocity length:size*2];    [data appendBytes:&_position length:size*2];    [data appendBytes:&_angularVelocity length:size];    [data appendBytes:&_angle length:size];        return data;}-(BOOL)isValid:(NSTimeInterval)latestUpdateTime {    return ([super isValid:latestUpdateTime] && ([self.userData length] == sizeof(NSUInteger)+sizeof(CGFloat)*6));}@end